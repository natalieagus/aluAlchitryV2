/*
    This file was generated automatically by Alchitry Labs 2.0.18-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/
module shifter (
    input [(32)-1:0] a,
    input [(5)-1:0] b,
    input [(6)-1:0] alufn_signal,
    output reg [(32)-1:0] shift
  );
  
  
  reg arith;
  reg [(5):0] R_493b669b_i, RR_493b669b_i;
  reg [(5):0] R_246e347c_j, RR_246e347c_j;
  
  reg [(32)-1:0] M_left_shifter_a;
  reg [(5)-1:0] M_left_shifter_b;
  reg M_left_shifter_pad;
  wire [(32)-1:0] M_left_shifter_shl;
  
  left_shifter left_shifter (
    .a(M_left_shifter_a),
    .b(M_left_shifter_b),
    .pad(M_left_shifter_pad),
    .shl(M_left_shifter_shl)
  );
  
  localparam _MP_SIZE_873232928 = 6'h20;
  reg [(32)-1:0] M_bit_reverse3_2in_in;
  wire [(32)-1:0] M_bit_reverse3_2in_reversed;
  
  bit_reverse #(
    .SIZE(_MP_SIZE_873232928)
  ) bit_reverse3_2in (
    .in(M_bit_reverse3_2in_in),
    .reversed(M_bit_reverse3_2in_reversed)
  );
  
  localparam _MP_SIZE_2120943755 = 6'h20;
  reg [(32)-1:0] M_bit_reverse3_2out_in;
  wire [(32)-1:0] M_bit_reverse3_2out_reversed;
  
  bit_reverse #(
    .SIZE(_MP_SIZE_2120943755)
  ) bit_reverse3_2out (
    .in(M_bit_reverse3_2out_in),
    .reversed(M_bit_reverse3_2out_reversed)
  );
  
  reg [(32)-1:0] M_choose_reverse_s0;
  reg [(64)-1:0] M_choose_reverse_in;
  wire [(32)-1:0] M_choose_reverse_out;
  
  genvar idx_0_887304262;
  
  generate
    for (idx_0_887304262 = 0; idx_0_887304262 < 32; idx_0_887304262 = idx_0_887304262 + 1) begin: forLoop_idx_0_887304262
      mux2 choose_reverse_idx_0_887304262 (
        .s0(M_choose_reverse_s0[(idx_0_887304262)]),
        .in(M_choose_reverse_in[(idx_0_887304262 * (2)) + (2)-1-:(2)]),
        .out(M_choose_reverse_out[(idx_0_887304262)])
      );
    end
  endgenerate
  
  reg [(32)-1:0] M_choose_left_right_s0;
  reg [(64)-1:0] M_choose_left_right_in;
  wire [(32)-1:0] M_choose_left_right_out;
  
  genvar idx_0_64367771;
  
  generate
    for (idx_0_64367771 = 0; idx_0_64367771 < 32; idx_0_64367771 = idx_0_64367771 + 1) begin: forLoop_idx_0_64367771
      mux2 choose_left_right_idx_0_64367771 (
        .s0(M_choose_left_right_s0[(idx_0_64367771)]),
        .in(M_choose_left_right_in[(idx_0_64367771 * (2)) + (2)-1-:(2)]),
        .out(M_choose_left_right_out[(idx_0_64367771)])
      );
    end
  endgenerate
  
  
  always @* begin
    M_bit_reverse3_2in_in = a;
    M_choose_reverse_s0 = {6'h20{alufn_signal[(1'h0)]}};
    M_choose_left_right_s0 = {6'h20{alufn_signal[(1'h0)]}};
    for (RR_493b669b_i = 0; RR_493b669b_i < 6'h20; RR_493b669b_i = RR_493b669b_i + 1) begin
      R_493b669b_i = (0) + RR_493b669b_i * (1);
      M_choose_reverse_in[(R_493b669b_i)*(2)+(2) - 1 -:(2)] = {M_bit_reverse3_2in_reversed[(R_493b669b_i)], a[(R_493b669b_i)]};
    end
    arith = 1'h0;
    if (alufn_signal[(1'h1)]) begin
      arith = 1'h1;
    end
    M_left_shifter_b = b;
    M_left_shifter_a = M_choose_reverse_out;
    M_left_shifter_pad = arith;
    M_bit_reverse3_2out_in = M_left_shifter_shl;
    for (RR_246e347c_j = 0; RR_246e347c_j < 6'h20; RR_246e347c_j = RR_246e347c_j + 1) begin
      R_246e347c_j = (0) + RR_246e347c_j * (1);
      M_choose_left_right_in[(R_246e347c_j)*(2)+(2) - 1 -:(2)] = {M_bit_reverse3_2out_reversed[(R_246e347c_j)], M_left_shifter_shl[(R_246e347c_j)]};
    end
    shift = M_choose_left_right_out;
  end
  
endmodule