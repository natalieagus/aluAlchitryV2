/*
    This file was generated automatically by Alchitry Labs 2.0.19-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module shifter (
        input wire [31:0] a,
        input wire [4:0] b,
        input wire [5:0] alufn_signal,
        output reg [31:0] shift
    );
    
    
    logic arith;
    logic [4:0] R_4f618e23_i;
    logic [4:0]RR_4f618e23_i;
    logic [4:0] R_785c4a04_j;
    logic [4:0]RR_785c4a04_j;
    
    logic [31:0] M_left_shifter_a;
    logic [4:0] M_left_shifter_b;
    logic M_left_shifter_pad;
    logic [31:0] M_left_shifter_shl;
    
    left_shifter left_shifter (
        .a(M_left_shifter_a),
        .b(M_left_shifter_b),
        .pad(M_left_shifter_pad),
        .shl(M_left_shifter_shl)
    );
    
    localparam _MP_SIZE_55733439 = 6'h20;
    logic [31:0] M_bit_reverse3_2in_in;
    logic [31:0] M_bit_reverse3_2in_reversed;
    
    bit_reverse #(
        .SIZE(_MP_SIZE_55733439)
    ) bit_reverse3_2in (
        .in(M_bit_reverse3_2in_in),
        .reversed(M_bit_reverse3_2in_reversed)
    );
    
    localparam _MP_SIZE_1111204983 = 6'h20;
    logic [31:0] M_bit_reverse3_2out_in;
    logic [31:0] M_bit_reverse3_2out_reversed;
    
    bit_reverse #(
        .SIZE(_MP_SIZE_1111204983)
    ) bit_reverse3_2out (
        .in(M_bit_reverse3_2out_in),
        .reversed(M_bit_reverse3_2out_reversed)
    );
    
    logic [31:0] M_choose_reverse_s0;
    logic [31:0][1:0] M_choose_reverse_in;
    logic [31:0] M_choose_reverse_out;
    
    genvar idx_0_1920905527;
    
    generate
        for (idx_0_1920905527 = 0; idx_0_1920905527 < 32; idx_0_1920905527 = idx_0_1920905527 + 1) begin: forLoop_idx_0_1920905527
            mux2 choose_reverse (
                .s0(M_choose_reverse_s0[idx_0_1920905527]),
                .in(M_choose_reverse_in[idx_0_1920905527]),
                .out(M_choose_reverse_out[idx_0_1920905527])
            );
        end
    endgenerate
    
    logic [31:0] M_choose_left_right_s0;
    logic [31:0][1:0] M_choose_left_right_in;
    logic [31:0] M_choose_left_right_out;
    
    genvar idx_0_111526867;
    
    generate
        for (idx_0_111526867 = 0; idx_0_111526867 < 32; idx_0_111526867 = idx_0_111526867 + 1) begin: forLoop_idx_0_111526867
            mux2 choose_left_right (
                .s0(M_choose_left_right_s0[idx_0_111526867]),
                .in(M_choose_left_right_in[idx_0_111526867]),
                .out(M_choose_left_right_out[idx_0_111526867])
            );
        end
    endgenerate
    
    
    always @* begin
        M_bit_reverse3_2in_in = a;
        M_choose_reverse_s0 = {6'h20{alufn_signal[1'h0]}};
        M_choose_left_right_s0 = {6'h20{alufn_signal[1'h0]}};
        for (RR_4f618e23_i = 0; RR_4f618e23_i < 6'h20; RR_4f618e23_i = RR_4f618e23_i + 1) begin
      R_4f618e23_i = (0) + RR_4f618e23_i * (1);
            M_choose_reverse_in[R_4f618e23_i] = {M_bit_reverse3_2in_reversed[R_4f618e23_i], a[R_4f618e23_i]};
        end
        arith = 1'h0;
        if (alufn_signal[1'h1]) begin
            arith = 1'h1;
        end
        M_left_shifter_b = b;
        M_left_shifter_a = M_choose_reverse_out;
        M_left_shifter_pad = arith;
        M_bit_reverse3_2out_in = M_left_shifter_shl;
        for (RR_785c4a04_j = 0; RR_785c4a04_j < 6'h20; RR_785c4a04_j = RR_785c4a04_j + 1) begin
      R_785c4a04_j = (0) + RR_785c4a04_j * (1);
            M_choose_left_right_in[R_785c4a04_j] = {M_bit_reverse3_2out_reversed[R_785c4a04_j], M_left_shifter_shl[R_785c4a04_j]};
        end
        shift = M_choose_left_right_out;
    end
    
endmodule